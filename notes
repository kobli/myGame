TODO (also see spellSystem.lua)
===============================
- change interface of the worldEntity and test it ..... or create EC system template and unittest it ... probably better
	- create templated entityComponent /manager/ EntityManager?
	- then create a concrete manager which can be observed and forwards events

use cases:
	- system reads / writes into single component type
		-> direct access to iterable container of single type components
	- system reads / writes into components of more than one type
		-> iterate all entities (and check, if each of them has all required components, then get components)
		-> have entities sorted into buckets by components they consist of
			-> access components from entity - probably by entity ID
			-> entities in buckets and components should probably be sorted
				- unless cache cannot handle forward skips in vector
	- component changed - send entityEvent - serialize the component and send it over network
		-> access component by component type and ID
	- add entity
	- remove entity
	- add component of a type (var) to entity
	- remove component of a type (var) to entity
	- create events (probably dummy functions in base, override in derived):
		- entity/component created/destroyed
? componentModified event - do not create the events in components
	- create/delete event can be created by EntityManager
		? is it necessary? which constructor / destr. is called during vector realloc?
	? update event ... created by systems
		- systems can create update event once - after they have finished updating the component
		x or update events could be created after each "writing" system iteration
			- not good for network - update only components which have really been modified



- fix player colliders not disappearing after disconnect
	- destroy events are not being sent, because we would be trying to serialize an object which is not fully constructed / is almost deleted
		-> do not send destr. events for components, just for whole entity... and recreate them on the client
			- what if later we want to destroy only a component? probably will be needed for magic
			- the problem is that we are trying to serialize incomplete objects
				=> remove componentPtr from entityEvent
	- get rid of componentPtr in entityEvent
		- create componentFactory
		- group components of same type inside entity into list? why / (why not)?
			- how does a user pick the right component? - difficult usage
				-> only one component of each type per object
					- what about graphics components? character casting a spell? (probably necessary only for effects)
 					- how about name (and class) above player? probably a separate component (not billboard but label - name from game, not from engine)
						=> only one comp. of each type
							- division into components should be game oriented - not engine oriented
							- rename graphicsComponent to appearance / mesh (sphereMesh, animatedMesh, textMesh)
								- should players name be a textMeshComponent (= part of the game world)? or should it be handled somewhere else by the GUI?
									-> by the GUI, because we may need to also add a sprite and we should already be able to collect all the data from the model
							- rename bodyComponent to Transform?
				- getComponent
					- each component type must have an ID - string or enum
		 				- what ID? enum? int? string?
							- ID is unreadable, string is too much data for networking
							- there is almost no overhead for enum compared to str - just create a new value in enum
							- binding to Lua is probably easier with string - but now probably unnecessary
						- it must be automatically de/serializable based on the ID
				- addComponent
					- pool / factory_with_ownership - what to call it?
					- vector of components - how to avoid unused components being synced to all clients?
						- currently the components are synced ... ? on create and on update
>>==========^
							- sync only on update (relevant clients) and on destroy (all clients)
								- create would be difficult because of relevancy change
								- destroy - not when destructor is called (it will probably be called during realloc too) but when component is released
					- on client how to find corresponding component when handling an update? probably through entity
						-> use the vector only for iterating components, not direct access / lookup
							- but the lookup has to be possible so we can recreate the reference in entity after vec realloc
>>============^
							- we can use the index - get index after first insert - it will stay the same after realloc
							- remember which elements are free
		- DO NOT send create events without data - the objects would be created (and exist for a moment - until an update comes ... maybe its sent right afer the 'create' event) with funny parameters 

- clean the code, remove useless printouts, refactor
- better hill climbing detection? so player cannot push other players around ... especially lower/no angular friction
- character sometimes falls through the ground
- character is not a wizard

- implement attack spells
	- the body of the spell (entity) only gives effectApplier to a character
	- body can die immediately (give effectAppliers once) or after some time (make sure everyone touching the body has effecApplier)
	- eA can die after some time / when character leaves the spell body
	x	area affectors with time period, that can deal damage and alter other player stats
		- player stats, HP
		- types of affectors
			- repetitive = give player a de/buff
			- apply_once = (only for damage?)
			- or only one type (apply_once) that either adds a buff or alters HP or .. 
	- graphic effects (particle systems, opaque glowing spheres, ..) with dynamic color and scale
	? buffs
		- list of Buff objects, each buff can affect several abilities (so such buffs can be removed easily) (multiplicative or additive), effect repeat timers, expiration timers
		- how does buff die? timer expired, canceled (character died / spell), the affector died, ..?
- multiplying effect with stacking bodies
- merging bodies from someone else
? interrupt casting when: character dies / takes dmg / moves (/ is teleported) / ...
	=> can these events be detected?
x on client binding controls to an entity (= client side prediction for movement) - YAGNI
- binding clients camera to an entity
- different modes for launching spell: from hands in look_at direction, at target location, ..?
- GUI
	-	number of each class in their team
	- which class does the player next to me have?
	- chat / at least TS3/.. for the start
	- changing spells, some kind of spellbook
	- interface for creating spells
	? testing spells
- it might be possible to simplify serialization of components using CRTP


notes
===============================
- in terrain 2 meter spacing between vertices is OK ... usually!!
- all logic is in systems, EntityComponents contain only data (which will be broadcasted to clients)
	- some systems will be implemented in C++, others in a scripting language
	- some systems will run on server, others on client
- what needs to be done when adding new component type: (not all of it if the component is serverside / does not send data)
	- add value to enum ComponentType
	- create derived class from EntityComponent
	- add virtual overloads in serdes.hpp and serializable.hpp
	- add case to the receive switch that creates the component if it does not exist
	- add field, getter and setter in the EntityComponent
- graphics component subtypes:
	* mesh (/ animated)
	* sphere
	- particleSystem
	- light
	- cube
	- textBillboard
	- billboard
	x skybox/dome
	x terrain
	x water surface
